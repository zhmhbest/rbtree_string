/*
    1 {Case:1} if(node has double child)
        //{最小后继}替换，转化为分离{最小后继}结点的问题。

    2 if(node has single child)

        2.1 if(node->color == Red)
            //不存在的情况
            //child->color == Red   违反规则:4
            //child->color == Black 违反规则:5

        2.2 {Case:2} if(node->color == Black)
            //child must red, else  违反规则:5
            if(parent) {
                if( IsLeftChild(node) ) {
                    BindLeft(parent, child);
                } else {
                    BindRight(parent, child);
                }
            } else {
                BindRoot(tree, child); //node is root.
            }
            SetColor(child, Black);
            //(parent, child] black depth : form 1 to 1.

    3 if(node is leaf)

        3.1 {Case:3} if(node->color == Red)
            //直接分离

        3.2 {Case:4} if(node->color == Black && node == tree->root)
            //当前树中只有一个node
            //直接分离

        3.3 if(node->color == Black && )
            //黑叶问题

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

    //Left leaf node
    *.........................*
    *...........[?]...........*
    *............p............*
    *.........../.\...........*
    *........../...\..........*
    *........./.....\.........*
    *.....[B]n.......s[?].....*
    *.............../.\.......*
    *...........[?]E...e[?]...*
    *.........................*

    //Right leaf node
    *.........................*
    *...........[?]...........*
    *............p............*
    *.........../.\...........*
    *........../...\..........*
    *........./.....\.........*
    *.....[?]s.......n[B].....*
    *......./.\...............*
    *...[?]e...E[?]...........*
    *.........................*

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

    3.3.1 {Case:5} if(sibling->color == Red)
        //黑叶、红兄、左子问题
        //parent must black, else 违反规则:4
        *.........................→.........................→.........................*
        *...........[B]...........→...........[B]...........→...........[B]...........*
        *...........(p)...........→............s............→............s............*
        *.........../.\...........→.........../.\...........→.........../.\...........*
        *........../...\..........→........../...\..........→........../...\..........*
        *........./.....\.........→........./.....\.........→........./.....\.........*
        *.....[B]n.......s[R].....→.....[R]p.......e[B].....→.....[R]p.......e[B].....*
        *.............../.\.......→......./.\...............→.........\...............*
        *...........[B]E...e[B]...→...[B]n...E[B]...........→..........E[B]...........*
        *.........................→.........................→.........................*
        SetColor(parent,  Red);
        SetColor(sibling, Black);
        RR(tree, parent);
        //parent black depth : from 2 to 2.

        //黑叶、红兄、右子问题
        *.........................→.........................→.........................*
        *...........[B]...........→...........[B]...........→...........[B]...........*
        *...........(p)...........→............s............→............s............*
        *.........../.\...........→.........../.\...........→.........../.\...........*
        *........../...\..........→........../...\..........→........../...\..........*
        *........./.....\.........→........./.....\.........→........./.....\.........*
        *.....[R]s.......n[B].....→.....[B]e.......p[R].....→.....[B]e.......p[R].....*
        *......./.\...............→.............../.\.......→.............../.........*
        *...[B]e...E[B]...........→...........[B]E...n[B]...→...........[B]E..........*
        *.........................→.........................→.........................*
        SetColor(parent,  Red);
        SetColor(sibling, Black);
        LL(tree, parent);
        //parent black depth : from 2 to 2.

    3.3.2 if(sibling->color == Black)
        //黑叶、黑兄问题
        //nephew要么2个要么不存在

        3.3.2.1 if( double black nephew || double null nephew )
            //黑叶、黑兄、无红侄问题

            3.3.2.1.1 {Case:6} if( IsRed(parent) )
                //黑叶、黑兄、无红侄、红父问题
                *.........................→.........................→.........................*
                *...........[R]...........→...........[B]...........→...........[B]...........*
                *............p............→............p............→............p............*
                *.........../.\...........→.........../.\...........→.............\...........*
                *........../...\..........→........../...\..........→..............\..........*
                *........./.....\.........→........./.....\.........→...............\.........*
                *.....[B]n.......s[B].....→.....[B]n.......s[R].....→................s[R].....*
                *.............../.\.......→.............../.\.......→.............../.\.......*
                *...........[B]?...?[B]...→...........[B]?...?[B]...→...........[B]?...?[B]...*
                *.........................→.........................→.........................*
                SetColor(parent,  Black);
                SetColor(sibling, Red);
                //parent black depth : from 2 to 2.

            3.3.2.1.2 {Case:7} if( IsBlack(parent) )
                //黑叶、黑兄、无红侄、黑父问题
                *.........................→.........................→.........................*
                *...........[B]...........→...........[B]...........→...........[B]...........*
                *............p............→............p............→............p............*
                *.........../.\...........→.........../.\...........→.............\...........*
                *........../...\..........→........../...\..........→..............\..........*
                *........./.....\.........→........./.....\.........→...............\.........*
                *.....[B]n.......s[B].....→.....[B]n.......s[R].....→................s[R].....*
                *.............../.\.......→.............../.\.......→.............../.\.......*
                *...........[B]?...?[B]...→...........[B]?...?[B]...→...........[B]?...?[B]...*
                *.........................→.........................→.........................*
                SetColor(sibling, Red);
                //parent black depth : from 3 to 2.
                //传递调整

        3.3.2.2 if( has red nephew )
            //黑叶、黑兄、有红侄问题

            3.3.2.2.1 {Case:8} if( far nephew is red )
                //黑叶、黑兄、有红侄、远红侄、左子问题
                *.........................→.........................→.........................*
                *...........[?]...........→...........[?]...........→...........[?]...........*
                *...........(p)...........→............s............→............s............*
                *.........../.\...........→.........../.\...........→.........../.\...........*
                *........../...\..........→........../...\..........→........../...\..........*
                *........./.....\.........→........./.....\.........→........./.....\.........*
                *.....[B]n.......s[B].....→.....[B]p.......e[B].....→.....[B]p.......e[B].....*
                *.............../.\.......→......./.\...............→.........\...............*
                *...........[?]E...e[R]...→...[B]n...E[?]...........→..........E[?]...........*
                *.........................→.........................→.........................*
                SwapColor(parent, sibling);
                SetColor(nephew_far, Black);
                RR(tree, parent);
                //(parent, nephew] black depth : from (1+?) to (1+?).

                //黑叶、黑兄、有红侄、远红侄、右子问题
                *.........................→.........................→.........................*
                *...........[?]...........→...........[?]...........→...........[?]...........*
                *...........(p)...........→............s............→............s............*
                *.........../.\...........→.........../.\...........→.........../.\...........*
                *........../...\..........→........../...\..........→........../...\..........*
                *........./.....\.........→........./.....\.........→........./.....\.........*
                *.....[B]s.......n[B].....→.....[B]e.......p[B].....→.....[B]e.......p[B].....*
                *......./.\...............→.............../.\.......→.............../.........*
                *...[R]e...E[?]...........→...........[?]E...n[B]...→...........[?]E..........*
                *.........................→.........................→.........................*
                SwapColor(parent, sibling);
                SetColor(nephew_far, Black);
                LL(tree, parent);
                //(parent, nephew] black depth : from (1+?) to (1+?).

            3.3.2.2.2 {Case:9} if( near nephew is Red )
                //黑叶、黑兄、有红侄、近红侄问题

                //黑叶、黑兄、有红侄、近红侄、左子侄问题
                *.........................→.........................*
                *...........[?]...........→...........[?]...........*
                *............p............→............p............*
                *.........../.\...........→.........../.\...........*
                *........../...\..........→........../...\..........*
                *........./.....\.........→........./.....\.........*
                *.....[B]n......(s)[B]....→.....[B]n.......E[B].....*
                *.............../.\.......→.............../.\.......*
                *...........[R]E...1[B]...→...........[B]3...s[R]...*
                *............./.\.........→................./.\.....*
                *.........[B]3...2[B].....→.............[B]2...1[B].*
                *.........................→.........................*
                SwapColor(nephew_near, sibling);
                LL(tree, sibling);
                //转换为远红侄情况{Case:8} sibling = parent->right;

                //黑叶、黑兄、有红侄、近红侄、右子问题
                *.........................→.........................*
                *...........[?]...........→...........[?]...........*
                *............p............→............p............*
                *.........../.\...........→.........../.\...........*
                *........../...\..........→........../...\..........*
                *........./.....\.........→........./.....\.........*
                *....[B](s)......n[B].....→.....[B]E.......n[B].....*
                *......./.\...............→......./.\...............*
                *...[B]1...E[R]...........→...[R]s...3[B]...........*
                *........./.\.............→...../.\.................*
                *.....[B]2...3[B].........→.[B]1...2[B].............*
                *.........................→.........................*
                SwapColor(nephew_near, sibling);
                RR(tree, sibling);
                //转换为远红侄情况{Case:8} sibling = parent->left;

*/

//#define rbtree_detach_PRINTSTEP

//■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■
//■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■

/*!
 * @name GetChildNumber
 */
#define RBTM_GetChildNumber(node) ( node ? ( ((node->left)?1:0) + ((node->right)?1:0) ) : 0 )

/*!
 * @name GetSingleChild
 */
#define RBTM_GetSingleChild(node)  ( (node->left) ? (node->left) : (node->right) )

/*!
 * @name GetSibling
 */
#define RBTM_GetSibling(node)  ( RBTM_ExistParent(node) ? \
    ( RBTM_IsLeftChild(node) ? RBTM_GetParent(node)->right : RBTM_GetParent(node)->left ) : NULL)

/*!
 * @name SwapKeyDat
 */
#define RBTM_SwapKeyDat(no1, no2) {                     \
    RBTKey tk  = (no1)->key;  RBTData td = (no1)->data; \
    (no1)->key = (no2)->key; (no1)->data = (no2)->data; \
    (no2)->key = tk;         (no2)->data = td;          \
}

/*!
 * @name SwapColor
 */
#define RBTM_SwapColorByTemp(no1, no2, tmp) { \
             tmp = (no1)->color;    \
    (no1)->color = (no2)->color;    \
    (no2)->color = tmp;             \
}
#define RBTM_SwapColor(no1, no2) { RBTColor tmp; RBTM_SwapColorByTemp(no1, no2, tmp); }

//■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■
//■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■ ■■■■■■■■

static void rbtree_detachBlackLeaf(RBTreeType tree, RBTNodeType node);
#include "rbtree_detach_BlackLeaf.inl.h"

/**
 * @name Detach Node
 * @warning 这是“Detach Key”的子进程！
 * @warning 这不是一个建议直接使用的方法！
 */
static RBTNodeType rbtree_detachNode(RBTreeType tree, RBTNodeType node) {
    if( !(tree && node) ) return NULL;
    int CHILD_NUM = RBTM_GetChildNumber(node);

    //!{Case:1} doube child
    if( 2 ==  CHILD_NUM ) {
        #ifdef rbtree_detach_PRINTSTEP
            printf("Detach: Case:1\n");
        #endif // rbtree_detach_PRINTSTEP
        RBTNodeType next = node->right;
        RBTM_GetMin(next); //获得最小后继
        RBTM_SwapKeyDat(node, next);
        node = next;
        CHILD_NUM = RBTM_GetChildNumber(node); //传递判断，CHILD_NUM绝对不为2
    }

    //!{Case:2} single child
    if( 1 == CHILD_NUM ) {
        #ifdef rbtree_detach_PRINTSTEP
            printf("Detach: Case:2\n");
        #endif // rbtree_detach_PRINTSTEP
        //node一定为黑色 child一定为红色
        RBTNodeType child = RBTM_GetSingleChild(node);
        if(node->parent) {
            //单子替换
            if( RBTM_IsLeftChild(node) ) {
                RBTM_BindLeft(node->parent, child);
            } else {
                RBTM_BindRight(node->parent, child);
            }
        } else {
            //node is root.
            RBTM_BindRoot(tree, child);
        }
        RBTM_SetColor(child, RBT_BLACK);
        return node;
    }

    //!{Case:3} red leaf
    if( RBTM_IsRed(node) ) {
        #ifdef rbtree_detach_PRINTSTEP
            printf("Detach: Case:3\n");
        #endif // rbtree_detach_PRINTSTEP
        //root is black, node must not root.
        //直接移除
        if( RBTM_IsLeftChild(node) ) {
            node->parent->left = NULL;
        } else {
            node->parent->right = NULL;
        }
        return node;
    } else {
        if(node->parent) {
            //!{Case:*}
            rbtree_detachBlackLeaf(tree, node);
        } else {
            //!{Case:4} node is root.
            #ifdef rbtree_detach_PRINTSTEP
                printf("Detach: Case:4\n");
            #endif // rbtree_detach_PRINTSTEP
            tree->root = NULL;
        }
        return node;
    }

}

static RBTNodeType rbtree_detachKey(RBTreeType tree, RBTKeyType key) {
    RBTNodeType node = rbtree_lookupKey(tree, key, NULL);
    return rbtree_detachNode(tree, node);
}

